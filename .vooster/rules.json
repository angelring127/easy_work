{
  "rules": [
    {
      "type": "prd",
      "content": "# Workeasy – Product Requirements Document (PRD)\n\n## 1. 제품 개요\n알바생 교대 근무표를 자동으로 생성·조정하고, 실시간 채팅 및 푸시 알림으로 팀 커뮤니케이션을 개선하는 소규모 카페·음식점용 SaaS.\n\n## 2. 문제 정의\n1. 매장 관리자가 엑셀·카톡으로 스케줄을 수작업 관리 → 시간 소모, 오류 잦음\n2. 교대 요청 처리 지연 → 근무 공백·혼선\n3. 변경 사항을 모든 알바생에게 실시간 전달하기 어려움\n\n## 3. 목표 (User Goal)\n매장 인력 스케줄링 시간을 대폭 단축하고 오류를 줄인다.\n\n## 4. 주요 사용자\n| 구분 | 핵심 니즈 |\n|------|-----------|\n| 매장 관리자(점장) | • 주간/월간 근무표를 신속히 작성 • 교대 요청을 빠르게 승인/거절 • 전 직원에게 공지를 즉시 전달 |\n| 알바생(파트타이머) | • 자신의 스케줄을 실시간 확인 • 교대 요청을 간편히 제출 • 변경 알림을 즉시 수신 |\n\n## 5. 핵심 기능 (MVP Scope)\n1. 스케줄 자동 배정 & 변경 요청 관리 (Feature A)\n   - 알바생 가용 시간 입력 후 한 클릭 자동 배치\n   - 드래그&드롭 수정, 휴무/근무 유형 관리\n2. 교대 일정 교환(Shift Swap) (Feature B)\n   - 알바생이 교대 요청 생성 → 담당자 알림 → 승인/거절 플로우\n3. 사내 채팅(1:1 & 그룹) (Feature C)\n   - 텍스트, 이모티콘, 공지 Pin, 이미 읽음 표시\n4. 푸시 알림(PWA) (Feature D)\n   - 근무 변경·교대 승인·채팅 멘션 알림\n5. 관리자 대시보드 (보조 기능)\n   - 인력 부족 경고, 오늘 교대 요청 현황, 빠른 승인 버튼\n\n## 6. 비 기능 요구사항\n- 모바일 PWA 중심, 데스크톱 웹 대응\n- 반응형 UI, 2초 이하 초기 로드\n- 99.9% 가용성, 메시지 지연 < 1초\n\n## 7. KPI\nPrimary: 스케줄 자동 생성 완료 건수 / 매장 / 주\nSecondary: 교대 요청 승인 평균 처리 시간, 30일 무료 → 유료 전환율\n\n## 8. 과금 모델 및 프로모션\n- 매장당 월 구독(기본 5인 포함, 추가 인원당 과금)\n- 런칭: 30일 무료 체험 후 자동 유료 전환\n\n## 9. 개발 전략 & 일정 (MVP)\n| 기간 | 마일스톤 |\n|------|-----------|\n| Week 1-2 | 요구사항 세부화, 디자인 시스템(shadcn) 세팅 |\n| Week 3-4 | 스케줄 자동 배정 알고리즘, 데이터 모델링(Supabase) |\n| Week 5-6 | Shift Swap, 푸시 알림 PWA 구현 |\n| Week 7-8 | 채팅(1:1, 그룹), 관리자 대시보드 ‑ β 릴리스 |\n| Week 9 | 버그 픽스, 퍼포먼스 튜닝 |\n| Week 10 | 공개 런칭 & 30일 무료 프로모션 시작 |\n\n## 10. 기본 기술 스택 (EasyNext Template)\nNext.js 15, Typescript, TailwindCSS, shadcn, lucide-react, Supabase(PostgreSQL, Auth, Realtime), @tanstack/react-query, es-toolkit, date-fns\n\n## 11. 향후 로드맵 (Post-MVP)\n- 출퇴근 타임시트 연동\n- 다지점 통합 대시보드\n- AI 수요 예측 기반 인력 최적화 추천\n",
      "writedAt": "2025-08-20T04:46:19.245Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: Workeasy는 Next.js 기반의 PWA를 사용하여 소규모 카페 및 음식점의 교대 근무표 자동 생성 및 관리, 실시간 팀 커뮤니케이션을 지원하는 SaaS 솔루션입니다. Supabase를 통해 데이터 저장 및 실시간 업데이트를 처리하며, 사용자 인터페이스는 shadcn 및 TailwindCSS를 활용하여 반응형으로 구현됩니다.\n- **Core Technology Stack**: Next.js 15, TypeScript, TailwindCSS, shadcn, lucide-react, Supabase (PostgreSQL, Auth, Realtime), @tanstack/react-query, es-toolkit, date-fns를 핵심 기술 스택으로 사용합니다.\n- **Key Technical Objectives**: 2초 이내 초기 로딩 속도, 99.9% 가용성, 1초 미만 메시지 지연 시간을 목표로 합니다. 스케줄 자동 생성 완료 건수 및 교대 요청 승인 평균 처리 시간을 주요 KPI로 설정합니다.\n- **Critical Technical Assumptions**: 알바생의 가용 시간 데이터가 정확하게 입력될 것으로 가정하며, Supabase의 안정적인 작동을 전제로 합니다. PWA 환경이 대부분의 사용자에게 적합하며, 데스크톱 웹 환경도 충분히 지원할 수 있다고 가정합니다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 프레임워크        | Next.js 15                  | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도 향상, SEO 최적화. API 라우팅 및 미들웨어 제공으로 백엔드 기능 통합 용이. |\n| 언어              | TypeScript                  | 정적 타입 지원으로 코드 안정성 및 유지보수성 향상. Next.js와 통합 용이. |\n| 스타일링          | TailwindCSS                 | 유틸리티 우선 스타일링으로 빠른 UI 개발 및 일관성 유지. 반응형 디자인 지원. |\n| UI 컴포넌트       | shadcn                      | 재사용 가능한 UI 컴포넌트 제공으로 개발 속도 향상 및 디자인 시스템 일관성 유지. |\n| 아이콘            | lucide-react                | 일관성 있는 벡터 기반 아이콘 제공. |\n| 데이터베이스       | Supabase (PostgreSQL)       | 안정적인 관계형 데이터베이스 제공. |\n| 인증              | Supabase Auth               | 사용자 인증 및 권한 관리 기능 제공. |\n| 실시간 통신       | Supabase Realtime           | 푸시 알림 및 채팅 기능 구현에 필요한 실시간 데이터 업데이트 지원. |\n| 데이터 페칭      | @tanstack/react-query       | 서버 상태 관리 및 데이터 캐싱을 통해 성능 최적화. |\n| 유틸리티          | es-toolkit                  | 다양한 유틸리티 함수 제공으로 개발 편의성 향상. |\n| 날짜 처리         | date-fns                    | 날짜 및 시간 관련 기능 제공. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js PWA)**:\n    - UI 컴포넌트: shadcn 기반의 재사용 가능한 UI 컴포넌트\n    - 상태 관리: @tanstack/react-query를 이용한 서버 상태 관리\n    - 페이지 라우팅: Next.js의 파일 기반 라우팅\n- **Backend (Supabase)**:\n    - 데이터베이스: PostgreSQL을 이용한 데이터 저장 및 관리\n    - 인증: Supabase Auth를 이용한 사용자 인증 및 권한 관리\n    - 실시간 통신: Supabase Realtime을 이용한 실시간 데이터 업데이트\n- **API Layer (Next.js API Routes)**:\n    - 인증 미들웨어: API 요청에 대한 인증 및 권한 검사\n    - 데이터 처리 로직: 데이터베이스 쿼리 및 비즈니스 로직 처리\n- **Push Notification Service (Supabase Realtime + PWA)**:\n    - PWA: Service Worker를 이용한 오프라인 지원 및 푸시 알림 처리\n    - Supabase Realtime: 데이터 변경 감지 및 푸시 알림 트리거\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js PWA)] --> B[API Layer (Next.js API Routes)]\n    B --> C[Backend (Supabase)]\n    C --> D[Push Notification Service (Supabase Realtime + PWA)]\n```\n\n- **Frontend (Next.js PWA)**: 사용자와의 인터랙션을 담당하며, API Layer를 통해 데이터를 요청하고 응답을 받아 UI를 업데이트합니다.\n- **API Layer (Next.js API Routes)**: Frontend의 요청을 받아 Backend에 전달하고, 인증 및 데이터 처리 로직을 수행합니다.\n- **Backend (Supabase)**: 데이터 저장, 인증, 실시간 통신을 담당하며, API Layer의 요청에 따라 데이터를 제공하고 업데이트합니다.\n- **Push Notification Service (Supabase Realtime + PWA)**: Supabase Realtime을 통해 데이터 변경을 감지하고, PWA를 통해 사용자에게 푸시 알림을 전송합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 스케줄 관리, 채팅 기능 등 도메인별로 코드를 분리합니다.\n- **Layer-Based Architecture**: 프레젠테이션 레이어, 비즈니스 로직 레이어, 데이터 접근 레이어를 분리합니다.\n- **Feature-Based Modules**: 각 기능별로 모듈을 구성하여 관련 코드들을 함께 관리합니다.\n- **Shared Components**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트들을 별도 모듈에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/          # 재사용 가능한 UI 컴포넌트\n│   ├── auth/           # 인증 관련 컴포넌트\n│   ├── schedule/       # 스케줄 관련 컴포넌트\n│   ├── chat/           # 채팅 관련 컴포넌트\n│   └── ui/             # shadcn 기반의 UI 컴포넌트\n├── pages/               # Next.js 페이지 라우팅\n│   ├── api/            # Next.js API Routes\n│   │   ├── auth/       # 인증 관련 API\n│   │   ├── schedule/   # 스케줄 관련 API\n│   │   └── chat/       # 채팅 관련 API\n│   ├── _app.tsx        # Next.js 앱 설정\n│   ├── _document.tsx   # Next.js 문서 설정\n│   ├── index.tsx       # 메인 페이지\n│   ├── login.tsx       # 로그인 페이지\n│   └── dashboard.tsx   # 대시보드 페이지\n├── services/            # 외부 API 연동 및 데이터 처리 로직\n│   ├── authService.ts  # 인증 서비스\n│   ├── scheduleService.ts # 스케줄 서비스\n│   └── chatService.ts   # 채팅 서비스\n├── utils/               # 유틸리티 함수\n│   ├── dateUtils.ts    # 날짜 관련 유틸리티\n│   └── helper.ts       # 기타 유틸리티\n├── types/               # 타입 정의\n│   ├── user.ts         # 사용자 타입\n│   ├── schedule.ts     # 스케줄 타입\n│   └── chat.ts         # 채팅 타입\n├── public/              # 정적 파일\n│   ├── images/         # 이미지 파일\n│   └── favicon.ico     # 파비콘\n├── styles/              # 스타일 파일\n│   └── globals.css     # 전역 스타일\n├── tailwind.config.js   # TailwindCSS 설정\n├── tsconfig.json        # TypeScript 설정\n└── package.json         # 프로젝트 설정\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: API 요청/응답 패턴 (RESTful API)\n- **Database Interaction**: Supabase 클라이언트를 이용한 데이터베이스 쿼리 및 트랜잭션 관리\n- **External Service Integration**: Supabase Auth, Realtime 서비스 연동\n- **Real-time Communication**: Supabase Realtime을 이용한 실시간 데이터 업데이트 및 푸시 알림\n- **Data Synchronization**: Supabase Realtime을 통한 데이터 변경 감지 및 클라이언트 데이터 동기화\n\n## 4. Performance & Optimization Strategy\n- Next.js의 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 활용하여 초기 로딩 속도 최적화\n- @tanstack/react-query를 사용하여 서버 상태 관리 및 데이터 캐싱\n- 이미지 최적화 및 코드 분할을 통해 번들 크기 최소화\n- Supabase Realtime을 이용한 실시간 데이터 업데이트 최적화\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js, TypeScript, TailwindCSS, Supabase 설정 및 개발 환경 구축\n- **Essential Features**: 스케줄 자동 배정, 교대 일정 교환, 사내 채팅, 푸시 알림, 관리자 대시보드 기본 기능 구현\n- **Basic Security**: 사용자 인증 및 권한 관리 기능 구현\n- **Development Setup**: 개발 환경 설정 및 CI/CD 파이프라인 구축\n- **Timeline**: Week 1-6\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 스케줄 자동 배정 알고리즘 개선, 교대 일정 교환 프로세스 최적화, 채팅 기능 확장, 관리자 대시보드 기능 추가\n- **Performance Optimization**: 초기 로딩 속도 최적화, 데이터베이스 쿼리 최적화, 실시간 통신 최적화\n- **Enhanced Security**: 보안 취약점 점검 및 보안 강화\n- **Monitoring Implementation**: 시스템 모니터링 및 로깅 시스템 구축\n- **Timeline**: Week 7-9\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Next.js, Supabase 등 기술 스택에 대한 숙련도 부족 및 예상치 못한 문제 발생 가능성\n    - **Mitigation Strategies**: 기술 스택 학습 및 충분한 테스트 수행, Supabase 기술 지원 활용\n- **Performance Risks**: 초기 로딩 속도 및 실시간 통신 성능 저하 가능성\n    - **Mitigation Strategies**: 코드 최적화, 이미지 최적화, 데이터베이스 쿼리 최적화, Supabase Realtime 성능 튜닝\n- **Security Risks**: 사용자 인증 및 데이터 보안 취약점 발생 가능성\n    - **Mitigation Strategies**: 보안 취약점 점검 및 보안 강화, Supabase Auth 보안 기능 활용\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연 및 예상치 못한 문제 발생 가능성\n    - **Contingency Plans**: 개발 일정 조정 및 우선순위 재설정, 추가 개발 인력 투입\n- **Resource Risks**: 개발 인력 부족 및 기술 숙련도 부족 가능성\n    - **Contingency Plans**: 추가 개발 인력 확보 및 기술 교육 지원\n- **Quality Risks**: 코드 품질 저하 및 테스트 부족 가능성\n    - **Contingency Plans**: 코드 리뷰 및 테스트 강화, 자동화된 테스트 환경 구축\n- **Deployment Risks**: 배포 환경 문제 및 배포 실패 가능성\n    - **Contingency Plans**: 배포 환경 사전 점검 및 테스트, 자동화된 배포 파이프라인 구축\n",
      "writedAt": "2025-08-20T04:46:19.245Z"
    },
    {
      "type": "guideline",
      "content": "\n  # Senior Developer Guidelines\n  \n  ## Must\n  \n  - always use client component for all components. (use `use client` directive)\n  - always use promise for page.tsx params props.\n  - use valid picsum.photos stock image for placeholder image\n  \n  ## Library\n  \n  use following libraries for specific functionalities:\n  \n  1. `date-fns`: For efficient date and time handling.\n  2. `ts-pattern`: For clean and type-safe branching logic.\n  3. `@tanstack/react-query`: For server state management.\n  4. `zustand`: For lightweight global state management.\n  5. `react-use`: For commonly needed React hooks.\n  6. `es-toolkit`: For robust utility functions.\n  7. `lucide-react`: For customizable icons.\n  8. `zod`: For schema validation and data integrity.\n  9. `shadcn-ui`: For pre-built accessible UI components.\n  10. `tailwindcss`: For utility-first CSS styling.\n  11. `supabase`: For a backend-as-a-service solution.\n  12. `react-hook-form`: For form validation and state management.\n  \n  ## Directory Structure\n  \n  - src\n  - src/app: Next.js App Routers\n  - src/components/ui: shadcn-ui components\n  - src/constants: Common constants\n  - src/hooks: Common hooks\n  - src/lib: utility functions\n  - src/remote: http client\n  - src/features/[featureName]/components/*: Components for specific feature\n  - src/features/[featureName]/constants/*\n  - src/features/[featureName]/hooks/*\n  - src/features/[featureName]/lib/*\n  - src/features/[featureName]/api.ts: api fetch functions\n  \n  ## Solution Process:\n  \n  1. Rephrase Input: Transform to clear, professional prompt.\n  2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n  3. Develop Solution:\n     - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n     - List steps numerically.\n     - \"To resolve these steps, I need the following solutions:\"\n     - List solutions with bullet points.\n  4. Validate Solution: Review, refine, test against edge cases.\n  5. Evaluate Progress:\n     - If incomplete: Pause, inform user, await input.\n     - If satisfactory: Proceed to final output.\n  6. Prepare Final Output:\n     - ASCII title\n     - Problem summary and approach\n     - Step-by-step solution with relevant code snippets\n     - Format code changes:\n      ```language:path/to/file\n       // ... existing code ...\n       function exampleFunction() {\n           // Modified or new code here\n       }\n       // ... existing code ...\n       ```\n     - Use appropriate formatting\n     - Describe modifications\n     - Conclude with potential improvements\n  \n  ## Key Mindsets:\n  \n  1. Simplicity\n  2. Readability\n  3. Maintainability\n  4. Testability\n  5. Reusability\n  6. Functional Paradigm\n  7. Pragmatism\n  \n  ## Code Guidelines:\n  \n  1. Early Returns\n  2. Conditional Classes over ternary\n  3. Descriptive Names\n  4. Constants > Functions\n  5. DRY\n  6. Functional & Immutable\n  7. Minimal Changes\n  8. Pure Functions\n  9. Composition over inheritance\n  \n  ## Functional Programming:\n  \n  - Avoid Mutation\n  - Use Map, Filter, Reduce\n  - Currying and Partial Application\n  - Immutability\n  \n  ## Code-Style Guidelines\n  \n  - Use TypeScript for type safety.\n  - Follow the coding standards defined in the ESLint configuration.\n  - Ensure all components are responsive and accessible.\n  - Use Tailwind CSS for styling, adhering to the defined color palette.\n  - When generating code, prioritize TypeScript and React best practices.\n  - Ensure that any new components are reusable and follow the existing design patterns.\n  - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n  - Always validate user inputs and handle errors gracefully.\n  - Use the existing components and pages as a reference for the new components and pages.\n  \n  ## Performance:\n  \n  - Avoid Premature Optimization\n  - Profile Before Optimizing\n  - Optimize Judiciously\n  - Document Optimizations\n  \n  ## Comments & Documentation:\n  \n  - Comment function purpose\n  - Use JSDoc for JS\n  - Document \"why\" not \"what\"\n  \n  ## Function Ordering:\n  \n  - Higher-order functionality first\n  - Group related functions\n  \n  ## Handling Bugs:\n  \n  - Use TODO: and FIXME: comments\n  \n  ## Error Handling:\n  \n  - Use appropriate techniques\n  - Prefer returning errors over exceptions\n  \n  ## Testing:\n  \n  - Unit tests for core functionality\n  - Consider integration and end-to-end tests\n  \n  ## Next.js\n  \n  - you must use promise for page.tsx params props.\n  \n  ## Shadcn-ui\n  \n  - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n  - example\n    ```\n    $ npx shadcn@latest add card\n    $ npx shadcn@latest add textarea\n    $ npx shadcn@latest add dialog\n    ```\n  \n  ## Supabase\n  \n  - if you need to add new table, please create migration. I'll paste it into supabase.\n  - do not run supabase locally\n  - store migration query for `.sql` file. in /supabase/migrations/\n  \n  ## Package Manager\n  \n  - use npm as package manager.\n  \n  ## Korean Text\n  \n  - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n  \n  You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n  Apply these principles judiciously, considering project and team needs.\n    ",
      "writedAt": "2025-08-20T04:46:19.245Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-20T04:46:19.245Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-20T04:46:19.245Z"
    }
  ]
}